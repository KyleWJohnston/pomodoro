#!/usr/bin/env python
# Adapted from : http://code.activestate.com/recipes/577358-pomodoro-timer/
from __future__ import print_function
from clize import run
from sigtools import modifiers
import sys
import time
import subprocess
from datetime import datetime
import os
import configparser

try:
    from PyQt5.QtWidgets import QMessageBox
    from PyQt5.Qt import QApplication
except ImportError:
    has_qt = False
else:
    has_qt = True


display = print
script_dir = os.path.dirname(__file__)
ALARM_FILE_DIRS = [
    '.',
    script_dir,
    sys.prefix,
    os.path.join(script_dir, "..", ".."),
]
ALARM_FILENAME = 'clock.mp3'
for alarm_file_dir in ALARM_FILE_DIRS:
    ALARM_FILE = os.path.join(alarm_file_dir, ALARM_FILENAME)
    if os.path.exists(ALARM_FILE):
        break
ALARM_CMD_FFPLAY = ["ffplay", "-nodisp", "-autoexit"]
ALARM_CMD_MPG123 = ["mpg123"]
ALARM_CMDS = (ALARM_CMD_MPG123, ALARM_CMD_FFPLAY)
DATA_FILENAME = os.path.expanduser("~/.pomodoro")
CONFIG_FILENAME = os.path.expanduser("~/.pomodoro.conf")
DEV_NULL = open(os.devnull, "w")


# Parsing config file :
config = configparser.ConfigParser()
config.read(CONFIG_FILENAME)
if 'DEFAULTS' not in config : #if the config doesn't exist or is of the wrong format
    #writes the default config to the file
    config['DEFAULTS'] = {'work':25, 'rest':5, 'long':15, 'cycles':4, 'start':0, 'repeat':0, 'alarm':True, 'notif':False, 'timer':False, 'seconds':True, 'autostart':False}
    with open(CONFIG_FILENAME, 'w') as configfile:
        config.write(configfile)
    config.read(CONFIG_FILENAME)
work_default = config['DEFAULTS'].getint('work', fallback=25)
rest_default = config['DEFAULTS'].getint('rest', fallback=5)
long_default = config['DEFAULTS'].getint('long', fallback=15)
cycles_default = config['DEFAULTS'].getint('cycles', fallback=4)
start_default = config['DEFAULTS'].getint('start', fallback=0)
repeat_default = config['DEFAULTS'].getint('repeat', fallback=0)
alarm_default = config['DEFAULTS'].getboolean('alarm', fallback=True)
notif_default = config['DEFAULTS'].getboolean('notif', fallback=False)
timer_default = config['DEFAULTS'].getboolean('timer', fallback=False)
seconds_default = config['DEFAULTS'].getboolean('seconds', fallback=True)
autostart_default = config['DEFAULTS'].getboolean('autostart', fallback=False)


def notify(title, content, autostart):
    if not has_qt:
        return autostart
    app = QApplication(sys.argv)
    msg = QMessageBox()
    msg.setIcon(QMessageBox.Information)
    msg.setText(content + ' Start next timer now?')
    msg.setWindowTitle(title)
    msg.setStandardButtons(QMessageBox.Yes | QMessageBox.Cancel | QMessageBox.Abort)
    msg.show()
    msg_return = msg.exec_()
    if msg_return == QMessageBox.Abort:
        exit()
    elif msg_return == QMessageBox.Yes:
        # Automatically begin next timer
        return True
    else:
        # Require user to begin next timer from command line
        return False


def tick(duration, timer, seconds):
    try:
        if timer:
            cli_timer(duration, seconds)
        else:
            time.sleep(duration)
    except KeyboardInterrupt:
        display("Interrupting")
        interrupt = True
    else:
        interrupt = False
    return interrupt


def play_alarm(filename):
    for alarm_cmd in ALARM_CMDS:
        cmd = alarm_cmd + [filename]
        try:
            p = subprocess.Popen(cmd, stdout=DEV_NULL, stderr=subprocess.PIPE)
            p.wait()
        except OSError:
            # error, try the next alarm cmd
            continue
        else:
            # successful
            return


def write_pomo(start, stop, tag, description):
    duration = (stop - start).total_seconds() / 60.
    if description == '':
        line = "{0},{1},{2},{3}\n".format(tag, start, stop, duration)
    else:
        line = "{0},{1},{2},{3},{4}\n".format(tag, start, stop, duration, description)
    if not os.path.exists(DATA_FILENAME):
        fd = open(DATA_FILENAME, "w")
        fd.write("work,start,end,duration\n")
    else:
        fd = open(DATA_FILENAME, "a")
    fd.write(line)
    fd.close()


def cli_timer(duration, seconds):
    for remaining in range(duration, -1, -1):
        sys.stdout.write("\r")
        hours, rem = divmod(remaining, 3600)
        mins, secs = divmod(rem, 60)
        if seconds:
            sys.stdout.write("Time remaining: {:0>2}:{:0>2}:{:0>2}".format(hours, mins, secs))
        elif remaining < 60:
            sys.stdout.write("Time remaining: less than 1 minute")
        else:
            sys.stdout.write("Time remaining: {:0>2}:{:0>2}".format(hours, mins))
        sys.stdout.flush()
        time.sleep(1)
    sys.stdout.write("\r")
    if seconds:
        sys.stdout.write("Time remaining: {:0>2}:{:0>2}:{:0>2}             ".format(00, 00, 00))
    else:
        sys.stdout.write("Time remaining: {:0>2}:{:0>2}             ".format(00, 00))
    print('\n')


@modifiers.kwoargs('long', 'cycles', 'start', 'repeat', 'alarm', 'notif', 'timer', 'seconds', 'autostart')
def main(work=work_default, rest=rest_default, long=long_default, cycles=cycles_default, start=start_default, repeat=repeat_default, alarm=alarm_default, notif=notif_default, timer=timer_default, seconds=seconds_default, autostart=autostart_default):
    """
    work : int
        nb of minuntes of work

    rest : int
        nb of minutes of rest

    long : int
        nb of minutes of long rest after completion of a set

    cycles : int
        nb of cycles in a set

    start : int
        nb of cycles already completed in the set

    repeat : int
        nb of cycles work-rest to do (use 0 to continue until user
        interruption)

    alarm : bool
        whether to play an alarm each time a pomodoro is finished or started

    notif : bool
        whether to send a message box each time a pomodoro is finished or
        started

    timer : bool
        whether to have cli timer visible

    seconds : bool
        whether to show the seconds

    autostart : bool
        whether to automatically start the next timer instead of manually
        pressing enter

    description : string
        description of the task to be saved with the CSV
    """
    cycle = start
    while repeat <= 0 or cycle != repeat:
        description_work = ''
        description_rest = ''

        # Work - prompt
        # If repeat is >0, continue until cycle == repeat. If repeat <=0, continue until user interrupts.
        display("Work now, cycle {}/{}".format((cycle % cycles) + 1, cycles))

        # Work - timer
        start = datetime.now()
        interrupted = tick(int(work) * 60, timer, seconds)
        if interrupted:
            break
        stop = datetime.now()
        write_pomo(start, stop, "work", '"' + description_work + '"')
        if alarm:
            play_alarm(ALARM_FILE)

        # Rest - prompt
        if (cycle + 1) % cycles == 0:
            # If set complete, long rest
            rest_time = int(long) * 60
            if notif:
                autostart = notify('pomodoro', 'Finished set, start timer to long rest now.', autostart)
            if not autostart:
                description_rest = input('Finished set. Enter note and then press enter to begin long rest: ')
            display("Long rest now")
        else:
            # If partial set, normal (short) rest
            rest_time = int(rest) * 60
            if notif:
                autostart = notify('pomodoro', 'Finished cycle, start timer to rest now.', autostart)
            if not autostart:
                description_rest = input('Finished cycle. Enter note and then press enter to begin rest: ')
            display("Rest now")

        # Rest - timer
        start = datetime.now()
        interrupted = tick(rest_time, timer, seconds)
        if interrupted:
            break
        stop = datetime.now()
        write_pomo(start, stop, "rest", '"' + description_rest + '"')
        if alarm:
            play_alarm(ALARM_FILE)
        if notif:
            autostart = notify('pomodoro', 'Finished rest, start timer to work now.', autostart)
        if not autostart:
            description_work = input('Finished rest. Enter note and then press enter to begin work: ')

        display("Cycle complete")
        cycle += 1


if __name__ == "__main__":
    run(main)
